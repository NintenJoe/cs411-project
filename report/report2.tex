%	@file FinalDocumentation.tex
%	@author Thomas Bogue, Joseph Ciurej
%	@date Spring 2014
%	
%   LaTeX source file for the design document for the CS411 project.  More 
%   information about the requirements for this documentation file can be found
%   here: "https://wiki.cites.illinois.edu/wiki/display/cs411sp14/Final+Report+Instructions"

\documentclass{article}
\usepackage[parfill]{parskip}		% Package that improves paragraph formatting
\usepackage[pdftex]{graphicx}		% Package that faciliates figure insertion
\usepackage{float}					% Package that allows for arbitrary figure insertion
\usepackage{hyperref}				% Package that allows for text hyperlinking
\usepackage{tikz}					% Package that facilitates box rendering

% The following code block changes a few parameters of the page to make the
% text fill up more space on any given page.  For our liking, the default 'article'
% template is too sparse.
\addtolength{\voffset}{-2cm}
\addtolength{\textheight}{4cm}
\addtolength{\oddsidemargin}{-1.5cm}
\addtolength{\textwidth}{2cm}

% This command creates blue boxes around class names.
% @see "http://tex.stackexchange.com/questions/36401/drawing-boxes-around-words"
%\newcommand\classname[2][]{\tikz[overlay]\node[fill=blue!20,inner sep=2pt, anchor=text, rectangle, rounded corners=1mm,#1] {#2};\phantom{#2}}
\newcommand\appname[1][]{\tikz[overlay]\node[fill=green!20,inner sep=2pt, anchor=text, rectangle, rounded corners=1mm,#1] { DatBigCuke };\phantom{ DatBigCuke}}
%\newcommand{\classname}[1] {\texttt{#1}}
\newcommand{\methodname}[1] {\texttt{#1}}
\newcommand{\insertdiagram}[2]
{
	\begin{figure}[H]
		\centering
		\fbox{\includegraphics[height=#2]{figures/#1}}
		\caption{UML Diagram for the #1 Class}
	\end{figure}
}

\begin{document}

	% Title Page %
	\title{DatBigCuke: Final Project Report}
	\author{Eunsoo Roh, Joshua Halstead, Kyle Nusbaum, Thomas Bogue, Joseph Ciurej \\
		University of Illinois: Urbana-Champaign (CS411)}
	\date{\today}
	\maketitle

	% Table of Contents %
	\tableofcontents
	\clearpage

	% Body %
	\section[Project Overview]{Brief Project Overview}
	The purpose of this project was to create an online service for college
	students to help them schedule and manage their academic deadlines

	The purpose of this project is to create an extension to the continuous 
	integration server Jenkins that facilitates chat communication between
	users of the server.  The main feature of this extension is an augmentation
	to the standard Jenkins user web pages that allows for messages to be 
	transferred between users connected to one or more of these pages through
	a dynamically updating web interface.

		\subsection[Motiviation]{Project Motivation}
		The primary purpose of this plugin is to enable quick and easy 
		communication between Jenkins users through the provision of an 
		integrated chat client as an augmentation to the Jenkins web interface.
		While other chat clients exist in abundance, the Jenkins chat plugin
		allows for easy integration into a familiar environment with minimal
		installation difficulties.

		\subsection[Goals]{Project Goals}
		The main goal of this project is to provide an intuitive, feature-rich
		chat client within the Jenkins web interface.  By integrating a chat client
		into the Jenkins interface, we aim to remove the need for extraneous chat 
		applications, thus providing a more seamless workflow.  Additionally,
		eliminating the need for extra applications minimizes dependencies on
		additional exterior applications, decreasing both maintenance and
		integration costs for users.

		In an attempt to enhance user satisfaction, we built the application with
		a variety of features, including:

		\begin{itemize}
			\item Peer-to-peer communication between users via a familiar chat
			interface.
			\item Group chat support to allow users to communicate with multiple
			team members simultaneously.
			\item Identification system that allows for user-specified names by
			both system administrators (via an admin file) and chat clients
			(via a user interface in the chat client).
			\item Persistence of chat logs to allow for users and management to 
			cross-reference past communications.
		\end{itemize}
		
		Our hope is that these features will serve to facilitate efficient
		communication between users and provide near-complete coverage of desired
		functionality.


	\section[Functions and Features]{Project Functions and Features}
	The overall architecture of the Jenkins chat plugin follows a traditional
	\href{http://en.wikipedia.org/wiki/Client\%E2\%80\%93server\textunderscore model}{client-server model} 
	where clients to the chat plugin send messages to
	a back-end server and this back-end server forwards incoming messages 
	based on provided recipient information.  The implementation for the server 
	component of the model (and the implementation for supporting back-end
	functionality) is programmed in Java while the client component is
	programmed with a combinaion of Javascript and HTML.  These two components
	communicate using websocket technology (provided by the 
	\href{https://github.com/mrniko/netty-socketio/releases}{Netty-SocketIO} library), 
	which allows for seamless and asynchronous client-server interaction.
	The plugin extends Jenkins to closely integrate the start-up and shut-down
	processes of the server component with the Jenkins server and to provide
	server access to clients through the Jenkins web interface.

		\subsection[Feature List]{Concise Functions and Features List}
		The core of the Jenkins chat plugin consists of the types used to
		implement the server and client components of the client-server model.
		For each of these primary components, the listing below describes the
		major functionality encapsulated by that primary component and provides
		a visual aid for its role in the project through a 
		\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

		\subsection[Basic Functions]{Overview of A Few Basic Functions}
		The core of the Jenkins chat plugin consists of the types used to
		implement the server and client components of the client-server model.
		For each of these primary components, the listing below describes the
		major functionality encapsulated by that primary component and provides
		a visual aid for its role in the project through a 
		\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

		\subsection[Advanced Functions]{Overview of Advanced Features}
		The core of the Jenkins chat plugin consists of the types used to
		implement the server and client components of the client-server model.
		For each of these primary components, the listing below describes the
		major functionality encapsulated by that primary component and provides
		a visual aid for its role in the project through a 
		\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

	\section[Project Implementation]{Project Implementation and Design}
	The core of the Jenkins chat plugin consists of the types used to
	implement the server and client components of the client-server model.
	For each of these primary components, the listing below describesd the
	major functionality encapsulated by that primary component and provides
	a visual aid for its role in the project through a 
	\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

        \subsection[Database Design]{Database Design\footnote{The full schema
        for our database is located in the appendix of this document.}}


        The primary design assumptions that \appname operates under and which
        influenced the database design are listed below.

        \begin{itemize}\itemsep0em
            \item There must be only one ``official group'' per course / section.
            \item A group can have subgroups or users as members.
            \item A course can have multiple sections, but not vice versa.
            \item An appointment has exactly one organizer (user).
            \item An appointment can have multiple users as attendees, and a
                user can attend multiple appointment.
            \item Deadlines can have multiple entities (user/group) and entities
                can have multiple deadlines.
            \item A group can have zero or more deadline authorities, and a user
                can be deadline authority of multiple groups.
        \end{itemize}

        The primary tables of \appname, viewable in Figure~\ref{fig:er},
        are the \texttt{group}, \texttt{user}, \texttt{group\_membership}, and
        the \texttt{deadline}/\texttt{metadata} tables. Central to the design of
        \appname was the idea of a \texttt{Group}, which represents both courses
        (i.e.\ public groups) and private subgroups. A group has many attributes,
        including a maintainer who serves as the group's authority (e.g.\ the
        professor of a course or the team leader of a group project). 

        By design, groups and their members form a tree-like heirarchy which is
        rooted by an institution (e.g UIUC). The nodes of the heirarchy can be
        one of two things: a subgroup or a user. For example, CS 411 is a group
        in our tree and contains a set of students and a set of project groups.
        This abstraction reduces duplication and offeres a cleaner interface to
        design around.

        Given that \appname is a deadline management web service, it is natural
        that the \texttt{Deadline} and \texttt{DeadlineMetadata} tables are
        central to its operation. Deadlines consist of a time, a name, and a type.
        From a user's perspective, they never interact with or directly view an
        entry from the \texttt{Deadline} table.
        
        Instead, we use a layer of indirection to allow user's to have independent
        control over their deadlines. This creates our ability to aggregate
        common deadlines into a canonical deadline. This layer of indirection is
        introduced via the \texttt{DeadlineMetadata} table, which consists of a
        \texttt{user\_id}/\texttt{deadline\_i}d pair and a reference to additional
        metadata (e.g.\ notes). It is the metadata that user's see and manipulate.
        Given this indirection, we're free to identify common deadlines amongst
        a group and generate a canonical deadline--called a \textit{communal}
        deadline--that is propogated to all current and future members of the
        group. Moreover, if a maintainer creates a similar deadline as an existing
        \textit{communal} deadline or a set of users' personal deadline, we
        upgrade and consolidate the matching deadlines to an \textit{endorsed}
        deadline. This new deadline is also propogated throughout the group and
        replaces the deadlines of all the original matching deadlines. Note that
        personal metadata is always preserved during aggregation and endorsement. 

        \begin{figure}[h]
            \centering
            \includegraphics[width=1\textwidth]{figures/er-diagram.pdf}
            \caption{\appname entity-relationship diagram using Information 
            Engineering notation.}
            \label{fig:er}
        \end{figure}

        \begin{figure}[h]
            \centering
            \includegraphics[width=.7\textwidth]{figures/er-legend.pdf}
            \caption{Information Engineering notation legend for referencing
            when examining Figure~\ref{fig:er}.} 
        \end{figure}

        \subsection[Data Gather]{Data Gathering}
        The major data needed to be collected and processed was course
        information, which we discovered were available via the
        \href{http://courses.illinois.edu/cisdocs/explorer}[CIS Data Explorer App].
        The CIS Data Explorer App provides access to course information in the
        form of XML. Its structured like a tree or forest where the root(s) are
        the schedules in XML for all the available years. Predictably, their
        children represent the semesters for that particular year. This tree-like
        structure continues until the leaves (i.e. the individual sections of a
        course) are reached.

        As such, we wrote a Python script to crawl and parse the tree of XML pages
        and then insert the processed data into our tables. After processing courses and
        sections for each semester, the script executes a SQL query to
        generate the entities of smallest unit, which we call a ``class''. This
        unit was strategically designed to split courses by their section titles,
        as some courses deserved some distinction between different sections e.g.
        CS 498 Algorithms vs. CS 498 Cloud Computing. The design of the crawler
        is general and performant enough so as to be adaptable to other university's
        schedules with minor tweaks.


		\subsection[Implementation Schedule]{Project Implementation Schedule and Tasks}
        The core of the \appname web service consists of a front-end,
        user-facing interface, a set of page request handlers for each individual
        web page, a set of request handlers for asynchronous \texttt{POST}s and
        \texttt{GET}s that allow seamless user interaction with \appname, a
        database abstraction layer, and the \texttt{MySQL} database itself.
            
            \subsubsection[Task Delegation]{Delegation of Project Tasks}
             Like many web services, our \appname web service lent itself well
             to the classic front-end, back-end, middleware division of labor.
             The back-end team consisted of Kyle and Eunsoo. Joe handled the
             front-end, and Tom and Josh the middleware. Naturally, some overlap
             occurred throughout the development of \appname, but we generally
             stayed true to the outlined division of labor. Below is the basic
             task delegation:

            \begin{itemize}\itemsep0em
                \item Eunsoo
                    \begin{itemize}\itemsep0em
                    \item Database creation, schema design, and server
                        maintainence.
                    \item Development of the database abstraction layer. This
                        is code that allows us to interact with the database
                        without directly constructing SQL queries everywhere.
                    \end{itemize}

                \item Kyle
                    \begin{itemize}\itemsep0em
                    \item Also worked on the database abstraction layer and the
                        request handlers.
                    \item Wrote user email verification and scheduler email
                        sending.
                    \end{itemize}

                \item Josh
                    \begin{itemize}\itemsep0em
                    \item Scraping course data from the UIUC course catalog.
                    \item Major work on the asynchronous request handlers which
                        bridge the front end to the back end.
                    \end{itemize}

                \item Tom
                    \begin{itemize}\itemsep0em
                    \item Wrote scheduling and aggregation algorithms.
                    \item Google API authentication and integration.
                    \end{itemize}
 
                \item Joe
                    \begin{itemize}\itemsep0em
                    \item Designed and created the website's front-end pages.
                    \item Also worked on the request handlers.
                    \end{itemize}

           \end{itemize}

			\subsubsection[Challenges]{Technical Challenges}
			The core of the Jenkins chat plugin consists of the types used to
			implement the server and client components of the client-server model.
			For each of these primary components, the listing below describes the
			major functionality encapsulated by that primary component and provides
			a visual aid for its role in the project through a 
			\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.


	\section[Appendix]{Miscellaneous Project Information}
	The core of the Jenkins chat plugin consists of the types used to
	implement the server and client components of the client-server model.
	For each of these primary components, the listing below describes the
	major functionality encapsulated by that primary component and provides
	a visual aid for its role in the project through a 
	\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

		\subsection[Dependencies]{Sources and Dependencies}
		Installation for the chat plugin has the following dependencies, which
		must be installed before the plugin itself can be installed:

		\begin{description}
			\item[\href{http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html}{Java Development Kit}] (v1.7+) \hfill \\
			A version of the standard Java development kit at least as recent 
			as version 1.7 is needed primarily to import extended networking 
			functionality only in later JDK versions.

			\item[\href{http://jenkins-ci.org/}{Jenkins}] (v1.509.3+) \hfill \\
			A version of Jenkins more recent than version 1.509.3 is needed
			to support the chat server plugin (older versions may work, but they
			have not been tested).

			\item[\href{https://github.com/mrniko/netty-socketio/releases}{Netty-SocketIO}] (v1.5.2+) \hfill \\ 
			An open source Java library that facilitates network communication 
			via websockets in Java.  This library is used by the chat plugin
			to aid in the transferral of mesages to and from chat clients.
		\end{description}

		After these dependencies are installed, installing the chat plugin itself
		is relatively straightforward.  The steps for performing this installation
		are as follows:

		\begin{enumerate}
			\item Navigate to the \textbf{plugin} subdirectory from the chat
			plugin source base directory.

			\item Run the script within this directory by the name of 
			\textbf{export.sh}.
		\end{enumerate}

		After performing the second step, a sequence of installations should
		follow.  After all these subsequent installations are complete, the
		plugin should be fully installed and accessible through Jenkins.

		\subsection[Other Information]{Other Relevant Information}
		TODO

\begin{verbatim}
CREATE TABLE `academic_entity` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `type` enum('institution','term','course','section','class') NOT NULL,
  `group_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `group_id` (`group_id`),
)

CREATE TABLE `class` (
  `id` int(11) NOT NULL,
  `institution_id` int(11) NOT NULL,
  `term_id` int(11) NOT NULL,
  `course_id` int(11) NOT NULL,
  `name` char(16) NOT NULL,
  `title` char(48) NOT NULL,
  `class_name` char(66) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_class_search_name` (`term_id`,`class_name`,`name`,`title`),
  UNIQUE KEY `idx_unique_class` (`course_id`,`title`),
  KEY `institution_id` (`institution_id`),
)

CREATE TABLE `course` (
  `id` int(11) NOT NULL,
  `institution_id` int(11) NOT NULL,
  `term_id` int(11) NOT NULL,
  `subject` char(8) NOT NULL,
  `cnumber` char(8) NOT NULL,
  `name` char(18) NOT NULL,
  `title` char(48) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_course` (`term_id`,`subject`,`cnumber`),
  UNIQUE KEY `idx_course_name` (`term_id`,`name`),
  KEY `institution_id` (`institution_id`),
)

CREATE TABLE `deadline` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(64) NOT NULL,
  `group_id` int(11) NOT NULL,
  `deadline` datetime NOT NULL,
  `type` char(3) NOT NULL DEFAULT 'PER',
  PRIMARY KEY (`id`),
  KEY `idx_deadline` (`deadline`),
  KEY `group_id` (`group_id`),
)

CREATE TABLE `deadline_metadata` (
  `user_id` int(11) NOT NULL,
  `deadline_id` int(11) NOT NULL,
  `notes` text,
  PRIMARY KEY (`user_id`,`deadline_id`),
  KEY `deadline_id` (`deadline_id`),
)

CREATE TABLE `group` (
  `id` int(11) NOT NULL,
  `name` char(70) NOT NULL,
  `description` text,
  `type` int(11) NOT NULL,
  `maintainerId` int(11) DEFAULT NULL,
  `academic_entity_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `maintainerId` (`maintainerId`),
  KEY `academic_entity_id` (`academic_entity_id`),
)

CREATE TABLE `group_membership` (
  `group_id` int(11) NOT NULL,
  `member_id` int(11) NOT NULL,
  UNIQUE KEY `idx_group_membership` (`group_id`,`member_id`),
  KEY `member_id` (`member_id`),
)

CREATE TABLE `group_type` (
  `type_id` int(11) NOT NULL,
  `type_name` char(16) DEFAULT NULL,
  PRIMARY KEY (`type_id`)
)

CREATE TABLE `institution` (
  `id` int(11) NOT NULL,
  `name` char(70) NOT NULL,
  PRIMARY KEY (`id`),
)

CREATE TABLE `membership_entity` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
)

CREATE TABLE `section` (
  `id` int(11) NOT NULL,
  `institution_id` int(11) NOT NULL,
  `term_id` int(11) NOT NULL,
  `course_id` int(11) NOT NULL,
  `snumber` char(8) NOT NULL,
  `title` char(48) DEFAULT NULL,
  `ref_id` char(8) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_unique_snumber` (`institution_id`,`term_id`,`course_id`,`snumber`),
  UNIQUE KEY `idx_ref_id` (`institution_id`,`term_id`,`ref_id`),
)

CREATE TABLE `term` (
  `id` int(11) NOT NULL,
  `institution_id` int(11) NOT NULL,
  `year` year(4) NOT NULL,
  `sindex` tinyint(4) NOT NULL,
  `name` char(32) NOT NULL,
  PRIMARY KEY (`institution_id`,`year`,`sindex`),
  UNIQUE KEY `id` (`id`),
)

CREATE TABLE `user` (
  `id` int(11) NOT NULL,
  `email` char(255) NOT NULL,
  `name` char(70) NOT NULL,
  `password` char(40) DEFAULT NULL,
  `salt` char(40) NOT NULL,
  `confirmed` tinyint(1) NOT NULL DEFAULT '0',
  `confirmUUID` char(36) NOT NULL,
  `refreshTok` char(64) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `email` (`email`),
  UNIQUE KEY `confirmUUID` (`confirmUUID`),
)
\end{verbatim}

\end{document}
