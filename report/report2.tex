%	@file FinalDocumentation.tex
%	@author Thomas Bogue, Joseph Ciurej
%	@date Spring 2014
%	
%   LaTeX source file for the design document for the CS411 project.  More 
%   information about the requirements for this documentation file can be found
%   here: "https://wiki.cites.illinois.edu/wiki/display/cs411sp14/Final+Report+Instructions"

\documentclass{article}
\usepackage[parfill]{parskip}		% Package that improves paragraph formatting
\usepackage[pdftex]{graphicx}		% Package that faciliates figure insertion
\usepackage{float}					% Package that allows for arbitrary figure insertion
\usepackage{hyperref}				% Package that allows for text hyperlinking
\usepackage{tikz}					% Package that facilitates box rendering

% The following code block changes a few parameters of the page to make the
% text fill up more space on any given page.  For our liking, the default 'article'
% template is too sparse.
\addtolength{\voffset}{-2cm}
\addtolength{\textheight}{4cm}
\addtolength{\oddsidemargin}{-1.5cm}
\addtolength{\textwidth}{2cm}

% This command creates blue boxes around class names.
% @see "http://tex.stackexchange.com/questions/36401/drawing-boxes-around-words"
%\newcommand\classname[2][]{\tikz[overlay]\node[fill=blue!20,inner sep=2pt, anchor=text, rectangle, rounded corners=1mm,#1] {#2};\phantom{#2}}
\newcommand\appname[2][]{\tikz[overlay]\node[fill=green!20,inner sep=2pt, anchor=text, rectangle, rounded corners=1mm,#1] {#2};\phantom{#2}}
\newcommand{\insertdiagram}[2]
{
	\begin{figure}[H]
		\centering
		\fbox{\includegraphics[height=#2]{figures/#1}}
		\caption{UML Diagram for the #1 Class}
	\end{figure}
}

\begin{document}

	% Title Page %
	\title{DatBigCuke: Final Project Report}
	\author{Eunsoo Roh, Joshua Halstead, Kyle Nusbaum, Thomas Bogue, Joseph Ciurej \\
		University of Illinois: Urbana-Champaign (CS411)}
	\date{\today}
	\maketitle

	% Table of Contents %
	\tableofcontents
	\clearpage

	% Body %
	\section[Project Overview]{Brief Project Overview}
	The purpose of this project was to create an online service for college
	students to help them schedule and manage their academic deadlines

	The purpose of this project is to create an extension to the continuous 
	integration server Jenkins that facilitates chat communication between
	users of the server.  The main feature of this extension is an augmentation
	to the standard Jenkins user web pages that allows for messages to be 
	transferred between users connected to one or more of these pages through
	a dynamically updating web interface.

		\subsection[Motiviation]{Project Motivation}
		The primary purpose of this plugin is to enable quick and easy 
		communication between Jenkins users through the provision of an 
		integrated chat client as an augmentation to the Jenkins web interface.
		While other chat clients exist in abundance, the Jenkins chat plugin
		allows for easy integration into a familiar environment with minimal
		installation difficulties.

		\subsection[Goals]{Project Goals}
		The main goal of this project is to provide an intuitive, feature-rich
		chat client within the Jenkins web interface.  By integrating a chat client
		into the Jenkins interface, we aim to remove the need for extraneous chat 
		applications, thus providing a more seamless workflow.  Additionally,
		eliminating the need for extra applications minimizes dependencies on
		additional exterior applications, decreasing both maintenance and
		integration costs for users.

		In an attempt to enhance user satisfaction, we built the application with
		a variety of features, including:

		\begin{itemize}
			\item Peer-to-peer communication between users via a familiar chat
			interface.
			\item Group chat support to allow users to communicate with multiple
			team members simultaneously.
			\item Identification system that allows for user-specified names by
			both system administrators (via an admin file) and chat clients
			(via a user interface in the chat client).
			\item Persistence of chat logs to allow for users and management to 
			cross-reference past communications.
		\end{itemize}
		
		Our hope is that these features will serve to facilitate efficient
		communication between users and provide near-complete coverage of desired
		functionality.


	\section[Functions and Features]{Project Functions and Features}
	The overall architecture of the Jenkins chat plugin follows a traditional
	\href{http://en.wikipedia.org/wiki/Client\%E2\%80\%93server\textunderscore model}{client-server model} 
	where clients to the chat plugin send messages to
	a back-end server and this back-end server forwards incoming messages 
	based on provided recipient information.  The implementation for the server 
	component of the model (and the implementation for supporting back-end
	functionality) is programmed in Java while the client component is
	programmed with a combinaion of Javascript and HTML.  These two components
	communicate using websocket technology (provided by the 
	\href{https://github.com/mrniko/netty-socketio/releases}{Netty-SocketIO} library), 
	which allows for seamless and asynchronous client-server interaction.
	The plugin extends Jenkins to closely integrate the start-up and shut-down
	processes of the server component with the Jenkins server and to provide
	server access to clients through the Jenkins web interface.

		\subsection[Feature List]{Concise Functions and Features List}
		The core of the Jenkins chat plugin consists of the types used to
		implement the server and client components of the client-server model.
		For each of these primary components, the listing below describes the
		major functionality encapsulated by that primary component and provides
		a visual aid for its role in the project through a 
		\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

		\subsection[Basic Functions]{Overview of A Few Basic Functions}
		For our function to describe, we chose a nice piece involved in adding
		a member to a private group. That is, the auto-completion of the email
		of potential users to be added. After the user types the first two
		characters of an email, we offer auto-completions of members who
		are able to be a part of this private group. We send the characters
		through ajax to a request handler on the back-end, which then forms
		a SQL query that looks like this:
\begin{verbatim}
SELECT u.id, u.email, gm.group_id
FROM user AS u
JOIN group_membership AS gm
ON u.id = gm.member_id
WHERE gm.group_id="CS 411" AND u.email LIKE "jh%"
\end{verbatim}
		(in this example the parent group to the private group the user is 
		adding to would be ``CS 411'', and the user is trying to look up the
		email ``jhalstead@gmail.com''.) The database would then return a list of
		potential emails, say it gives back [``jhalstead@gmail.com'',
		``jhalla@gmail.com'']. This gets passed back to the front-end, and JQuery
		populates a dropdown menu with these two emails. Of course after the
		user chooses one and hits Submit, the email is inserted appropriately
		into the database.

		\subsection[Advanced Functions]{Overview of Advanced Features}
		Our first advanced feature is what we call the deadline aggregation. The idea
		behind the aggregation is that many people in a class will add canonical deadlines
		such as the times a homework is due, or the time of an exam. It would be nice,
		then, if these deadlines were pushed to all the other users in that class.
		That is the goal of the aggregation algorithm. We implement by having
		three levels of ``trust'' for a deadline. The lowest level is a Personal
		deadline, the next level is a Communal deadline (one that many people have 
		agreed on,) and an Endorsed deadline (one that is confirmed by a group leader
		or professor.) The different levels are given different colors on the site.

		The aggregation algorithm fits into this scheme by automatically deciding
		on, and creating, the Communal deadlines. We use statistical analysis methods
		to determine if a deadline should be made Communal, given all the entered
		Personal deadlines, and taking into account the size of the group. Once a deadline
		has been aggregated, all users in the course (even if they add the course after
		the aggregation,) will be able to view this deadline.

		Our second feature is the group meeting scheduling. The meeting scheduler
		allows a private group to find a time to work together on a deadline by
		giving a list of times when everyone that needs to make the meeting is free,
		and allowing the user to choose from these times and send an email to each
		group member informing of the meeting. This turned out to be very challenging,
		involving many different components of the project. The availability of each
		group member is based on their Google Calendars, so we had to work with the
		Google API to get this information. Users our asked to give our app read
		access to their Google Calendars, and this access is stored with the user.

		The scheduling itself uses an algorithm we wrote to determine times where
		everyone is free, taking into account the meeting duration, everyone's
		available times, and overnight ``off-limits times'' the user chooses (so
		that meetings are not scheduled for silly times like three in the morning.)
		The available times are used to populate a modal, the user can choose one
		and give an email message, and we craft and send the email to all the group
		members in the meeting.

	\section[Project Implementation]{Project Implementation and Design}
	The core of the Jenkins chat plugin consists of the types used to
	implement the server and client components of the client-server model.
	For each of these primary components, the listing below describes the
	major functionality encapsulated by that primary component and provides
	a visual aid for its role in the project through a 
	\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

		\subsection[Database Design]{Data and Database Design}
		The core of the Jenkins chat plugin consists of the types used to
		implement the server and client components of the client-server model.
		For each of these primary components, the listing below describes the
		major functionality encapsulated by that primary component and provides
		a visual aid for its role in the project through a 
		\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

		\subsection[Server Implementation]{Implementation Details and Design}
		The core of the Jenkins chat plugin consists of the types used to
		implement the server and client components of the client-server model.
		For each of these primary components, the listing below describes the
		major functionality encapsulated by that primary component and provides
		a visual aid for its role in the project through a 
		\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

		\subsection[Implementation Schedule]{Project Implementation Schedule and Tasks}
		The core of the Jenkins chat plugin consists of the types used to
		implement the server and client components of the client-server model.
		For each of these primary components, the listing below describes the
		major functionality encapsulated by that primary component and provides
		a visual aid for its role in the project through a 
		\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

			\subsubsection[Task Delegation]{Delegation of Project Tasks}
			The core of the Jenkins chat plugin consists of the types used to
			implement the server and client components of the client-server model.
			For each of these primary components, the listing below describes the
			major functionality encapsulated by that primary component and provides
			a visual aid for its role in the project through a 
			\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

			\subsubsection[Technical Challenges]{Technical Challenges}
			Working with the Google API was very difficult.
			Looking at the documentation, it seemed like it should have been more simple
			than it turned out to be. The main stumbling point was that Google refuses to
			send back data to anything other than an authenticated app, which can only be
			that one running on the actually server. Thus, testing any of the Google API
			usage locally was an impossibility. Since there were quite a few instances
			where the server was down during development, testing the Google API integration
			was often not something that could even be done. Unfortunately, the specifics
			of the Google authentication also turned out to not be as clear as we could
			have hoped, and many attempts failed in unhelpful ways.

			The most helpful tool
			was found a bit later, the OAuth 2.0 Playground, which cleared up a lot about
			how exactly the API queries should be formed. Good advice to help mitigate
			these difficulties would be to really take some time to work on figuring
			out the Google API requests and authentication process before integrating
			them into the app so that it can go much smoother.

			\subsubsection[Other Challenges]{Other Challenges}
			Our major challenge with this project was time. Due to large projects in
			other courses that many of us had, we were quite pressed for time. Despite
			this, however, we managed to create something we were all satisfied with.
			In the end there were a few kinks and bugs, and a few minor features were
			weakened in the process of development, but nothing specific stands out
			in terms of failure to meet the original specifications.

			The database
			schema changed some: we decided early on not to store scheduled appointments
			and instead to have the groups notify their members of the meeting (we helped
			automate this by adding an option to send an email to the group.) The reason
			for this was because deadlines and appointments differ in that an appointment
			has a duration, and the heterogeneous mix of deadlines and appointments
			did not seem like something that would be easily presentable or very worthwhile.


	\section[Appendix]{Miscellaneous Project Information}
	The core of the Jenkins chat plugin consists of the types used to
	implement the server and client components of the client-server model.
	For each of these primary components, the listing below describes the
	major functionality encapsulated by that primary component and provides
	a visual aid for its role in the project through a 
	\href{http://www.csci.csusb.edu/dick/samples/uml0.html}{UML diagram}.

		\subsection[Dependencies]{Sources and Dependencies}
		Installation for the chat plugin has the following dependencies, which
		must be installed before the plugin itself can be installed:

		\begin{description}
			\item[\href{http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html}{Java Development Kit}] (v1.7+) \hfill \\
			A version of the standard Java development kit at least as recent 
			as version 1.7 is needed primarily to import extended networking 
			functionality only in later JDK versions.

			\item[\href{http://jenkins-ci.org/}{Jenkins}] (v1.509.3+) \hfill \\
			A version of Jenkins more recent than version 1.509.3 is needed
			to support the chat server plugin (older versions may work, but they
			have not been tested).

			\item[\href{https://github.com/mrniko/netty-socketio/releases}{Netty-SocketIO}] (v1.5.2+) \hfill \\ 
			An open source Java library that facilitates network communication 
			via websockets in Java.  This library is used by the chat plugin
			to aid in the transferral of mesages to and from chat clients.
		\end{description}

		After these dependencies are installed, installing the chat plugin itself
		is relatively straightforward.  The steps for performing this installation
		are as follows:

		\begin{enumerate}
			\item Navigate to the \textbf{plugin} subdirectory from the chat
			plugin source base directory.

			\item Run the script within this directory by the name of 
			\textbf{export.sh}.
		\end{enumerate}

		After performing the second step, a sequence of installations should
		follow.  After all these subsequent installations are complete, the
		plugin should be fully installed and accessible through Jenkins.

		\subsection[Other Information]{Other Relevant Information}
		TODO

\end{document}
